\documentclass{article}
\usepackage{fullpage}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
%\usepackage{url}            % simple URL typesetting
%\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
%\usepackage{nicefrac}       % compact symbols for 1/2, etc.
%\usepackage{microtype}      % microtypography

%\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amssymb,amsmath}
\usepackage{natbib}
\usepackage{amsthm}
\newtheorem{Proposition}{Proposition}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\sign}{sign}
\DeclareMathOperator*{\Lik}{Lik}
\DeclareMathOperator*{\Peaks}{Peaks}
\DeclareMathOperator*{\HotSpots}{HotSpots}
\newcommand{\Cost}{\text{Cost}}
\usepackage{stfloats}
\DeclareMathOperator*{\Diag}{Diag}
\DeclareMathOperator*{\TPR}{TPR}
\DeclareMathOperator*{\Segments}{Segments}
\DeclareMathOperator*{\Changes}{Changes}
\DeclareMathOperator*{\FPR}{FPR}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\maximize}{maximize}
\DeclareMathOperator*{\minimize}{minimize}
\newcommand{\ZZ}{\mathbb Z}
\newcommand{\NN}{\mathbb N}
\newcommand{\RR}{\mathbb R}

\begin{document}

\title{A functional pruning algorithm for constrained optimal segmentation}

\author{
  Toby Dylan Hocking\\
  Department of Human Genetics\\
  McGill University\\
  Montreal, QC H2R-2G9 Canada \\
  \texttt{toby.hocking@mail.mcgill.ca} \\
  %% examples of more authors
   \\
  Guillem Rigaill \\
  University of Evry \\
  Evry, France \\
  \texttt{guillem.rigaill@evry.fr} \\
  %% \AND
  %% Coauthor \\
  %% Affiliation \\
  %% Address \\
  %% \texttt{email} \\
  %% \And
  %% Coauthor \\
  %% Affiliation \\
  %% Address \\
  %% \texttt{email} \\
  %% \And
  %% Coauthor \\
  %% Affiliation \\
  %% Address \\
  %% \texttt{email} \\
}

\maketitle

\begin{abstract}
  Change-point detection is a central problem in time series and
  genomic data sets. In several kinds of data it is desirable to
  constrain the possible change-points to obtain a more interpretable
  model. We propose a new constrained Pruned Dynamic Programming
  Algorithm (cPDPA) which recovers the optimal change-points subject
  to affine constraints on adjacent segment means. We use this
  algorithm for isotonic regression and peak detection.
\end{abstract}

\section{Introduction}

Change-point detection is a central problem in many fields. When there
are no constraints other than the number of change-points or segments,
the Pruned Dynamic Programming Algorithm (PDPA) can be used to recover
the change-points with minimum cost \citep{pruned-dp}. The Functional
Pruning Optimal Partitioning (FPOP) algorithm can be used when there
is no constraint on the number of change-points, but there is a
positive penalty constant \citep{FPOP}. 

In the unconstrained change-point detection model, there is no
constraint on the direction of changes that can be recovered. However,
in several kinds of data it is desirable to constrain the possible
change-points to obtain a more interpretable model. For example, in
genomic data it is desirable to only consider models that can be
easily interpreted in terms of peaks and background
\citep{PeakSeg}. This amounts to forcing an up change after each down
change, and vice versa.

The isotonic regression problem is another example of constrained
change-point detection. Typically there is no limit on the number of
changes, as long as they are all in the same direction. This problem
can be solved using the pool-adjacent-violators algorithm
\citep{mair2009isotone}. An L1 relaxed version of this problem is
nearly-isotonic regression \citep{tibshirani2011nearly}.

TODO discuss isotonic DP \citep{isotonic-dp}, functional pruning
\citep{phd-johnson}, reduced isotonic regression
\citep{hardwick2014optimal}, unimodal segmentation
\citep{haiminen2008algorithms}, histogram construction
\citep{halim2009fast}.

\subsection{Contributions}

The main contribution of this paper is a family of algorithms for
solving constrained segmentation problems. These algorithms are
guaranteed to recover the exact solution to the constrained
segmentation problem. Furthermore, we show that these algorithms have
empirical time complexity which is linear in the number of data
points.

\section{Related work}
\label{sec:related}

The models we consider in this paper are constrained versions of the
optimal segmentation model \citep{Segmentor}. The
unconstrained model can be computed using a dynamic programming
algorithm (DPA) \citep{bellman}, or a pruned dynamic programming
algorithm (pDPA) \citep{pruned-dp}. Both algorithms are guaranteed to
recover the exact solution to the unconstrained model, but there are
two important differences. The pDPA is more complicated to implement,
but is also computationally faster than the DPA. For segmenting a
sequence of $n$ data points, the pDPA takes on average $O(n\log n)$
time whereas the DPA takes $O(n^2)$ time.

The constraints that we consider in this paper are a generalization of
the peak detection model \citep{PeakSeg} and the isotonic regression
model \citep{mair2009isotone}. Rather than searching all possible
change-points to find the most likely model with $k$ segments, we
propose to constrain the possible change-points so that the segment
means may be more easily interpreted.

\section{From unconstrained to constrained maximum likelihoood
  segmentation}
\label{sec:model}

In this section we first discuss the existing unconstrained maximum
likelihood model, and then we discuss a more general framework for
constrained maximum likelihood segmentation.

\subsection{Unconstrained maximum likelihood segmentation}

Assume we have a sequence of $n$ count data $\mathbf y\in\ZZ_+^n$ to
segment. For the Segment Neighborhood model we first fix a maximum
number of segments $ K_{\max}\leq n$. The unconstrained maximum
likelihood segmentation model is defined as the most likely mean
vector $\mathbf m\in\RR^n$ with exactly 
$K\in\{1, \dots, K_{\max}\}$ distinct piecewise constant segments:
\begin{align}
  \label{unconstrained}
  \mathbf{\hat m}^K(\mathbf y) =
    \argmin_{\substack{
  \mathbf m\in\RR^{n}
\\
  \mathbf c\in\{-1,0,1\}^{n-1}
  }} &\ \ 
    \sum_{t=1}^n \ell( m_t,  y_t) 
\\
    \text{subject to} &\ \  1+\sum_{t=1}^{n-1} I(c_t \neq 0) = K, 
\nonumber\\
& \ \ c_t = -1 \Rightarrow m_{t} > m_{t+1} \text{ (change down)}
\nonumber\\
& \ \ c_t = 0 \Rightarrow m_{t} = m_{t+1}  \text{ (no change)}
\nonumber\\
& \ \ c_t = 1 \Rightarrow m_{t} < m_{t+1} \text{ (change up)}
\nonumber
\end{align}
where the Poisson loss function is
\begin{equation}\label{eq:loss}
  \ell( m,  y)= m - y \log m.
\end{equation} 
The $c_t = \sign(m_{t+1} - m_{t})$ variable is the sign of the change
after data point $t$. Every $t$ such that $c_t \neq 0$ is a
change-point, and the model complexity is the number of segments
$1+\sum_{t=1}^{n-1} I(c_t \neq 0)$, where $I$ is the indicator function.

We refer to (\ref{unconstrained}) as the ``unconstrained'' model
since $\mathbf{\hat m}^K(\mathbf y)$ is the most likely segmentation
of all possible models with $K$ piecewise constant segments ($K-1$
change-points). 
Although (\ref{unconstrained}) is a non-convex optimization problem,
the sequence of segmentations
$\mathbf{\hat m}^1(\mathbf y), \dots, \mathbf{\hat m}^{K}(\mathbf y)$
can be computed in $O(K n^2)$ time using the standard dynamic
programming algorithm \citep{bellman}, or in $O(K n \log n)$ time
using dynamic programming with functional pruning \citep{pruned-dp,
  johnson, Segmentor}.

\subsection{The PeakSeg constrained maximum likelihood model}
\label{sec:constrained}

To introduce the PeakSeg model constraint \citep{PeakSeg}, we first define
the peak indicator for $t\in\{1, \dots, n-1\}$ as
\begin{equation}
  \label{eq:peaks}
  P_t(\mathbf c) = \sum_{i=1}^t c_i,
\end{equation}
which is the cumulative sum of change-point variables $c_i$ up to data
point $t$. In general for the unconstrained model
$P_t(\mathbf c)\in\ZZ$, which is problematic in our biological
application (ChIP-seq peak detection), since we want to classify each
segment and data point into one of two states
$P_t(\mathbf c)\in \{0, 1\}$ (0 for background noise after a change
down, 1 for a peak after a change up).
% For example, if
% $\mathbf m = \left[\begin{array}{ccccccc}1.1 & 1.1 & 2 & 2 & 4 & 4 &
%     3\end{array}\right]$, with two changes up followed by one change
% down, then
% $\mathbf P(\mathbf m) = \left[\begin{array}{ccccccc}0 & 0 & 1 & 1 & 2
%     & 2 & 1 \end{array}\right]$ and so this model is not feasible for
% the peaks constraint $P_t(\mathbf m)\in \{0, 1\}$.
Thus we constrain the peak indicator $P_t(\mathbf
c)\in\{0, 1\}$, which results
in the constrained problem
\begin{align}
  \label{PeakSeg}
  \mathbf{\tilde m}^K(\mathbf y) =
    \argmin_{\substack{
  \mathbf m\in\RR^{n}
\\
  \mathbf c\in\{-1,0,1\}^{n-1}
  }} &\ \ 
    \sum_{t=1}^n \ell( m_t,  y_t) 
\tag{\textbf{PeakSeg}}
\\
    \text{subject to} &\ \  1+\sum_{t=1}^{n-1} I(c_t \neq 0) = K, 
\nonumber\\
& \ \ c_t = -1 \Rightarrow m_{t} > m_{t+1} \text{ (change down)}
\nonumber\\
& \ \ c_t = 0 \Rightarrow m_{t} = m_{t+1}  \text{ (no change)}
\nonumber\\
& \ \ c_t = 1 \Rightarrow m_{t} < m_{t+1} \text{ (change up)}
\nonumber\\
\forall t\in\{1, \dots, n-1\}, &\ \ P_t(\mathbf c) \in\{0, 1\}.
\nonumber
\end{align}
The only difference with the unconstrained problem
(\ref{unconstrained}) is that we have added the constraint
$P_t(\mathbf c) \in\{0, 1\}$. Another way to interpret the constrained
\ref{PeakSeg} problem is that the sequence of changes in the segment
means $\mathbf m$ must begin with a positive change and then
alternate: up, down, up, down, ... (and not up, up, down). Thus the
even-numbered segments may be interpreted as peaks $P_t(\mathbf c)=1$,
and the odd-numbered segments may be interpreted as background
$P_t(\mathbf c)=0$.

\subsection{The problem our algorithm solves}

The PeakSegPDPA code in the coseg R package exactly solves the
following optimization problem.

\begin{align}
  \mathbf{\bar m}^K(\mathbf y) =
    \argmin_{\substack{
  \mathbf m\in\RR^{n}
\\
  \mathbf c\in\{-1,0,1\}^{n-1}
  }} &\ \ 
    \sum_{t=1}^n \ell( m_t,  y_t) 
  \label{PeakSegPDPA}
\\
    \text{subject to} &\ \  1+ \sum_{t=1}^{n-1} I(c_t \neq 0) = K, 
\nonumber\\
& \ \ c_t = -1 \Rightarrow m_{t} \geq m_{t+1} \text{ (change down or no change)}
\nonumber\\
& \ \ c_t = 0 \Rightarrow m_{t} = m_{t+1}  \text{ (no change)}
\nonumber\\
& \ \ c_t = 1 \Rightarrow m_{t} \leq m_{t+1} \text{ (change up or no change)}
\nonumber\\
\forall t\in\{2, \dots, n\}, &\ \ P_t(\mathbf c) \in\{0, 1\}.
\nonumber
\end{align}
The only difference with the \ref{PeakSeg} problem is that we have
changed the strict inequality constraints to non-strict inequality
constraints. Thus the \ref{PeakSeg} model has exactly $K$ distinct
segment means, but this model (\ref{PeakSegPDPA}) has \emph{at most}
$K$ distinct segment means (some may be equal due to the non-strict
equality constraints). Note that for $K=4$, the solution
$(\mathbf m = \left[\begin{array}{cccc}1 & 2 & 2 & 3 \end{array}\right],
  \mathbf c = \left[\begin{array}{ccc}  1 & -1 & 1 \end{array}\right])$
is feasible for this problem (\ref{PeakSegPDPA}), 
but is not feasible for \ref{PeakSeg} (since $c_2=-1$ but $m_2 = m_3$).

Note that unlike the unconstrained model, increasing the number of
non-zero change variables ($c_t\neq 0$) does not always decrease the
cost. For example, consider the data set
$\mathbf y = \left[\begin{array}{ccc}1 & 3 & 9 \end{array}\right]$.
For $K=2$ segments both models have the same optimal solution,
$(\mathbf m = \left[\begin{array}{ccc}2 & 2 & 9 \end{array}\right],
  \mathbf c = \left[\begin{array}{cc}  0 & 1 \end{array}\right])$,
which has a Poisson loss of $\approx -9.6$. 
For $K=3$ segments the solution of unconstrained model
(\ref{unconstrained}) has a smaller loss of $\approx -10.1$
$(\mathbf m = \left[\begin{array}{ccc}1 & 3 & 9 \end{array}\right],
  \mathbf c = \left[\begin{array}{cc}  1 & 1 \end{array}\right])$,
but the solution of the constrained model (\ref{PeakSegPDPA})
has a larger loss of $\approx -8.5$
$(\mathbf m = \left[\begin{array}{ccc}1 & 6 & 6 \end{array}\right],
  \mathbf c = \left[\begin{array}{cc}  1 & -1  \end{array}\right])$. 
Note that the \ref{PeakSeg} solution with $K=3$ is undefined for this data set.

\begin{Proposition}
  Let $(\mathbf m, \mathbf c)$ be the solution to
  (\ref{PeakSegPDPA}). If $c_t=0 \Leftrightarrow m_t = m_{t+1}$ for
  all $t\in\{1, \dots, n-1\}$ then $(\mathbf m, \mathbf c)$ is also
  the solution to \ref{PeakSeg}. Otherwise, the \ref{PeakSeg} solution
  is undefined.
\end{Proposition}

\begin{proof}
  TODO
\end{proof}

\subsection{The FPOP version}

In real ChIP-seq data sets we are only interested in the \ref{PeakSeg}
solutions
$\mathbf{\tilde m}^1(\mathbf y), \mathbf{\tilde m}^3(\mathbf y), \dots$
which start with a change up, and end with a change down. To select
one of those segmentations we typically use the following criterion
\begin{equation}
  \label{eq:selection}
  K^*_\lambda = \argmin_{k\in 1,3, \dots}
  \lambda k +
\sum_{t=1}^n
  \ell[ \tilde m_t^k(\mathbf y),  y_t ],
\end{equation}
where $\lambda\in\RR_+$ is a non-negative penalty parameter 
that controls the optimal number of segments $K^*_\lambda$
(larger $\lambda$ yields fewer segments).
When the number of segments is very large $K =O(N)$, 
it computationally expensive to recover this model
using the $O(K N\log N)$ PeakSegPDPA, 
since it computes all models from 1 to $K$ segments.

It would be computationally faster if we could recover the model
$\mathbf{\tilde m}^{K}(\mathbf y)$ by itself, as in the $O(N\log N)$
FPOP algorithm \citep{johnson, FPOP}. This motivates the following
optimization problem,
\begin{align}
  \mathbf{\bar m}^\lambda(\mathbf y) =
    \argmin_{\substack{
  \mathbf m\in\RR^{n}
\\
  \mathbf c\in\{-1,0,1\}^{n-1}
  }} &\ \ 
\lambda\sum_{t=1}^{n-1} I(c_t =1)
+
\sum_{t=1}^n \ell( m_t,  y_t) 
  \label{PeakSegFPOP}
\\
    \text{subject to} 
& \ \ c_t = -1 \Rightarrow m_{t} \geq m_{t+1} \text{ (change down or no change)}
\nonumber\\
& \ \ c_t = 0 \Rightarrow m_{t} = m_{t+1}  \text{ (no change)}
\nonumber\\
& \ \ c_t = 1 \Rightarrow m_{t} \leq m_{t+1} \text{ (change up or no change)}
\nonumber\\
\forall t\in\{2, \dots, n\}, &\ \ P_t(\mathbf c) \in\{0, 1\}.
\nonumber
\end{align}

We refer to problem (\ref{PeakSegFPOP}) as the penalized version of
the constrained problem (\ref{PeakSegPDPA}). The constraint on the
number of non-zero change variables $c_t\neq 0$ has been removed, and
term penalizing the number of up changes $c_t=1$ has been added to the
optimization objective.  The solution to this problem is computed by
the PeakSegFPOP function of the coseg R package.

\begin{Proposition}
  For any data set $\mathbf y\in\ZZ_+^n$ and any penalty parameter
  $\lambda\in\RR_+$, let $(\mathbf m,\mathbf c)$ be the solution to
  the penalized problem (\ref{PeakSegFPOP}). It is the same as the
  solution to the contrained problem (\ref{PeakSegPDPA}) with
  $K=\sum_{t=1}^{n-1} c_t$ segments.
\end{Proposition}

\begin{proof}
  TODO
\end{proof}

%%%% update rules
\newcommand{\FCC}{\widetilde{C}}
\newcommand{\M}{\mathcal{M}}
\section{Constrained Dynamic Programming Problem}

In this section we explain the general form of the problem that our algorithm solves.

\subsection{Some definitions}

A segmentation $m$ is described as a set of contiguous segments $\{s_1, ... s_{|m|} \}$, where $|m|$ is the number of segments of $m$
We consider the set of all segmentation up to $n$: $\M_n$ 
or the set of all possible segmentation in $K$ segments: $\M^K_n$.
We define $r_m$ as the last segment of $m$.

We aim at optimizing over all possible segmentations $m$ in $\M^K_n$ or $\M_n$
 the quantity
$\sum_{r \in m} \sum_{i \in s_{r}} \ell(y_i, \mu_{r})$ subject to
the following $K-1$ linear constraints. 

\begin{eqnarray*}
a_{1,1}.\mu_1 \ + & a_{1,2}.\mu_2  & \geq  b_1 \\
\cdots \ +&  \cdots & \geq \cdots \\
a_{k,k}.\mu_{k} + & a_{k,k+1}.\mu_{k+1}  & \geq  b_{k} \\
\cdots \ +&  \cdots & \geq \cdots  \\
a_{K-1,K-1}.\mu_{K-1} \ +& a_{K-1,K}.\mu_K & \geq  b_{K-1},
\end{eqnarray*}
with all $a_{k,k+1} \neq 0$, $a_{k,k} \in \mathbb{R}$ and
$b_{k} \in \bar{\mathbb{R}}.$ In other words we aim at recovering the
best segmentation with successive mean parameters that obey the
constraints.

Some examples:
\begin{enumerate}
\item If we take all $a_{k,k+1} =1$, $a_{k,k}=0$ and $b_{k} = - \infty$ we recover the standard segmentation in the mean problem.
\item If we take all $a_{k,k+1} =1$, $a_{k,k}=-1$ and $b_{k} = 0$ we
  recover the isotonic regression problem (segment means always
  increasing).
\item For the PeakSeg model we take all $b_{k} = 0$. For odd $k$ we
  take $a_{k,k+1} =1$, $a_{k,k}=-1$ and for even $k$ we take
  $a_{k,k+1} =-1$, $a_{k,k}=1$.
\end{enumerate}

\subsection{Functional cost representation}
To optimize this quantity we will consider the following functional quantity:

\begin{equation}
\FCC^k_t(\mu) =  \underset{m \in \M^K_n, \mu_r |  r \neq r_m}{\min} 
		\{ 
		   \underset{r \in m, r \neq r_m}{\sum} 
		   \underset{i \in r, i \leq t  }{\sum} \ell(y_i, \mu_{r}) 
		+ 
		   \underset{i \in r_m, i \leq t}{\sum} \ell(y_i, \mu)
		\}  
\end{equation}



\begin{eqnarray*}
\text{subject to} \\
a_{1,1}. \mu_1 \ + & a_{1,2}. \mu_2  & \geq  b_1 \\
\cdots \ + & \cdots & \geq \cdots \\
a_{k-1,k-1}. \mu_{k-1} \ + &a_{k-1,k}. \mu_{k}  & \geq  b_{k-1} \\
\end{eqnarray*}

$\FCC^k_t(\mu)$ is the best possible cost achievable in $k$ segment up to point $t$ with a $k$-th
segment mean of $mu$.

\subsection{Update rule}
We can then consider the following update rule

\begin{equation}
\FCC^{k+1}_{t+1}(\mu) = \min \{ \FCC^{k+1}_{t}(\mu)  , \underset{\mu' | a_{k,k}. \mu' + a_{k,k}. \mu  \geq  b_{k}}{\min} \{ \FCC^{k}_{t}(\mu') \}  \} + \ell(y_{t+1}, \mu)
\end{equation}

This update rule states that the best segmentation up to $t+1$ in $k+1$ segment with a last mean element of $\mu$ either has its $k$-th changepoint:
\begin{itemize}
\item before $t$ and in that case we should take the best possible segmentation up to $t$ in $k+1$
segments with a last mean of $\mu$ and then add  $\ell(y_{t+1}, \mu)$, that is:
$$\FCC^{k+1}_{t}(\mu) + \ell(y_{t+1}, \mu),$$

\item at $t$ and in that case we should take the best possible segmentation up to $t$ in $k$ segments
such that the last mean $\mu_k=\mu'$ validates the $k-th$ constraint with $\mu_{k+1}=\mu$ and then add  $\ell(y_{t+1}, \mu)$, that is:
 $$\underset{\mu' | a_{k,k}. \mu' + a_{k,k}. \mu  \geq  b_{k}}{\min} \{ \FCC^{k}_{t}(\mu') \} + \ell(y_{t+1}, \mu).$$
\end{itemize}


\subsection{Constraint}
Assuming we have a piecewise description of $\FCC^{k}_{t}(\mu')$ on $I$ ordered intervals of $\mathbb{R}$
then it is straightforward to recover the function:
$\underset{\mu' | a_{k,k}. \mu' + a_{k,k}. \mu  \geq  b_{k}}{\min} \{ \FCC^{k}_{t}(\mu') \}.$

The update rule is a priori valid for more complex constraints, typically quadratic constraints, yet recovering
$\underset{\mu' | a_{k,k}. \mu' + a_{k,k}. \mu  \geq  b_{k}}{\min} \{ \FCC^{k}_{t}(\mu') \}$ from $\FCC^{k}_{t}(\mu')$ would possibly be much more difficult.


\section{Algorithm for PeakSeg model}

In this section we explain how our method works for the PeakSeg model.
To do this we are using a R beta implementation of the algorithm.

\subsection{Segment Neighborhood version}

For the Segment Neighborhood algorithm we begin as usual by computing
a functional representation of the optimal cost in 1 segment up to
data point $t$. 
\begin{equation*}
  \label{eq:C1b}
  \FCC_{1,t}(\mu) = \sum_{i=1}^t \gamma_i(\mu),
\end{equation*}
where $\gamma_t(\mu)=\ell(y_t, \mu)$ is the cost of using the mean
$\mu$ for single data point $t$ (for example the Gaussian or Poisson
loss).

Next we define the minimum cost in 2 segments up to data point 2 as
\begin{equation*}
  \label{eq:C22}
  \FCC_{2,2}(\mu) = \FCC_{1,1}^{\leq}(\mu) + \gamma_2(\mu),
\end{equation*}
where for a function $f:\RR\rightarrow\RR$ the min-less operator
yields another function $f\leq:\RR\rightarrow\RR$ such that
\begin{equation}
  \label{eq:min-less}
  f^{\leq}(\mu) = \min_{x\leq \mu} f(x).
\end{equation}
The algorithm relies on the ability to compute an exact representation
of functions such as $C_{1,1}^{\leq}$
(Figure~\ref{fig:min-operators}). Since the cost functions $C_{1,t}$
are convex, we can easily find the minimum $\mu_t^*$, and then compute
the following exact representation
\begin{equation*}
  \FCC_{1,t}^\leq(\mu)=
  \begin{cases}
    \FCC_{1,t}(\mu_t^*) & \text{ if } \mu \geq \mu_t^*,\\
    \FCC_{1,t}(\mu) & \text{ otherwise.}
  \end{cases}
\end{equation*}

\begin{figure}[!t]
  \parbox{3in}{
    \begin{center}
    \input{figure-1-min-more-operator}
    \end{center}
  }
  \parbox{3in}{
    \begin{center}
      \input{figure-1-min-less-operator}
    \end{center}
  }
  \caption{\label{fig:min-operators} \textbf{Left:} The min-more
    operator is $C^{\geq}(\mu)=\min_{x\geq \mu}C(x)$. \textbf{Right:}
    The min-less operator is $C^{\leq}(\mu)=\min_{x\leq
      \mu}C(x)$.}
\end{figure}

The next step is to compute the minimum cost in 2 segments up to data
point 3, for which there is a choice of two change-points.
\begin{equation*}
  \FCC_{2,3}(\mu) = \min
  \begin{cases}
    \FCC_{2,2}(\mu)+\gamma_3(\mu), \\
    \FCC_{1,2}^{\leq}(\mu)+\gamma_3(\mu)
  \end{cases}
\end{equation*}
We have already computed an exact representation of the $C_{2,2}$
term, which is the cost a change after the first data point. Now we
need to compare it with the $C_{1,2}^{\leq}$ term, which is the cost
of a change after the second data point. This is a crucial step in
which the \texttt{MinEnvelope} sub-routine computes an exact
representation of the minimum of these two functions
(Figure~\ref{fig:min-envelope}).

\begin{figure}[!t]
  \begin{center}
    \input{figure-2-min-envelope}
  \end{center}
  \caption{\label{fig:min-envelope} The cost $C_{s,t}$ in $s$ segments
    up to $t$ data points is computed using the min envelope
    $M_{s,t-1}$. \textbf{Left:} the min envelope for $s=3$ segments up
    to data point $t=34$ is the minimum of two functions:
    $C^{\geq}_{2,34}$ is the cost if the second segment ends at data
    point $t=34$, and $C_{3,34}$ is the cost if the second segment
    ends before that. \textbf{Middle:} the optimal cost for $s=3$
    segments up to data point $t=35$ is the sum of the min envelope
    $M_{3,34}$ and the cost of the next data point
    $\gamma_{35}$. \textbf{Right:} in the next step, the
    algorithm prunes all previously considered change-points (cost
    $C_{3,35}$), and only considers the model with a the second segment
    ending at data point $t=35$ (cost $C^{\geq}_{2,35}$).}
\end{figure}

The updates continue for every data point $t\in\{3, ..., n\}$
\begin{equation*}
  \FCC_{2,t}(\mu) = \min
  \begin{cases}
    \FCC_{2,t-1}(\mu) + \gamma_t(\mu),\\
    \FCC_{1,t-1}^{\leq}(\mu) + \gamma_t(\mu).
  \end{cases}
\end{equation*}

For the third segment we first compute the minimum cost up to data point 3
\begin{equation*}
  \FCC_{3,3}(\mu) = \FCC_{2,2}^{\geq}(\mu) + \gamma_3(\mu),
\end{equation*}
where the more-min operator $f^\geq$ is defined analogously to the
min-less operator (Figure~\ref{fig:min-operators}). The update formula
for the minimum cost up to data point $t\in\{4, ..., n\}$ is
\begin{equation*}
  \FCC_{3,t}(\mu) = \min
  \begin{cases}
    \FCC_{3,t-1}^{\geq}(\mu)+\gamma_t(\mu),\\
    \FCC_{2,t-1}^{\geq}(\mu)+\gamma_t(\mu)
  \end{cases}
\end{equation*}
In general for $s$ segments, we use
\begin{equation}
  \FCC_{s,s}(\mu) = \FCC_{s-1,s-1}^{*}(\mu) + \gamma_s(\mu),
\end{equation}
and for $t\in\{s+1, ..., n\}$
\begin{equation}
  \FCC_{s,t}(\mu) = \min
  \begin{cases}
    \FCC_{s,t-1}^{*}(\mu)+\gamma_t(\mu),\\
    \FCC_{s-1,t-1}^{*}(\mu)+\gamma_t(\mu),
  \end{cases}
\end{equation}
where * means less-min for even-numbered segments $s$, and more-min
for odd-numbered segments.

\subsection{Optimal Partitioning}

TODO: describe OP version.

\section{Results}

\subsection{Accuracy on ChIP-seq data}

TODO: some commentary about PeakSegDP vs coseg vs Segmentor
feasibility and optimality in the benchmark data set.

\begin{figure}[b!]
  \centering
  \includegraphics[width=\textwidth]{figure-test-error-dots}
  \caption{Test AUC on 7 benchmark data sets, interactive version at 
\url{http://bl.ocks.org/tdhock/raw/886575874144c3b172ce6b7d7d770b9f/}}
  \label{fig:test-error-dots}
\end{figure}
% \includegraphics[width=0.45\textwidth]{figure-min-train-error-Segmentor}
% \includegraphics[width=0.45\textwidth]{figure-min-train-error-PeakSegDP}

TODO: some more in-depth discussion on the difference between train
and test error results. coseg is always better than Segmentor in terms
of minimum train error (figure?). But Segmentor has a low false
positive and true positive rate, so it is easy to get a low test error
(just pick the model with the most peaks). But coseg has a
significantly higher AUC, about the same as PeakSegDP.

\subsection{Timings}

%TODO make small versions of these figures.
\begin{figure}[b!]
  \centering
  \parbox{0.49\textwidth}{
    %\includegraphics[width=0.45\textwidth]{figure-PDPA-intervals-all}
    \input{figure-PDPA-intervals-small}
  }
  \parbox{0.49\textwidth}{
    %\includegraphics[width=0.45\textwidth]{figure-PDPA-timings}
    \input{figure-PDPA-timings-small}
  }
  \caption{Timing results on 2752 segmentation problems from the
    McGill histone mark ChIP-seq benchmark data. For each problem we
    ran the PeakSegPDPA with $K_{\text{max}}=19$ segments.
    \textbf{Left}: number of intervals stored by the algorithm,
    \textbf{Right}: timings in seconds (median line and min/max
    band).}
  \label{fig:timings}
\end{figure}

\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}

